// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

contract;

use std::hash::Hash;
use std::hash::keccak256;
use std::bytes::Bytes;
use std::bytes_conversions::u256::*;

const N: u32 = <%= 2**power %>; // Domain size
const K1: u256 = <%= k1 %>;   // Plonk k1 multiplicative factor to force distinct cosets of H
const K2: u256 = <%= k2 %>;   // Plonk k2 multiplicative factor to force distinct cosets of H

const ZERO: u256 = 0;
const N_PUBLIC = <%= nPublic %>;

// OMEGAS
// Omega, Omega^{1/3}
const W1: u256 = <%='0x' + BigInt(w).toString(16) + 'u256' ;%>;
const WR: u256 = <%='0x' + BigInt(wr).toString(16) + 'u256' ;%>;

// Omega_3, Omega_3^2
const W3: u256 = <%='0x' + BigInt(w3).toString(16) + 'u256' ;%>;
const W3_2: u256 = <%='0x' + BigInt(w3_2).toString(16) + 'u256' ;%>;

// Omega_4, Omega_4^2, Omega_4^3
const W4: u256 = <%='0x' + BigInt(w4).toString(16) + 'u256' ;%>;
const W4_2: u256 = <%='0x' + BigInt(w4_2).toString(16) + 'u256' ;%>;
const W4_3: u256 = <%='0x' + BigInt(w4_3).toString(16) + 'u256' ;%>;

// Omega_8, Omega_8^2, Omega_8^3, Omega_8^4, Omega_8^5, Omega_8^6, Omega_8^7
const W8_1: u256 = <%='0x' + BigInt(w8).toString(16) + 'u256' ;%>;
const W8_2: u256 = <%='0x' + BigInt(w8_2).toString(16) + 'u256' ;%>;
const W8_3: u256 = <%='0x' + BigInt(w8_3).toString(16) + 'u256' ;%>;
const W8_4: u256 = <%='0x' + BigInt(w8_4).toString(16) + 'u256' ;%>;
const W8_5: u256 = <%='0x' + BigInt(w8_5).toString(16) + 'u256' ;%>;
const W8_6: u256 = <%='0x' + BigInt(w8_6).toString(16) + 'u256' ;%>;
const W8_7: u256 = <%='0x' + BigInt(w8_7).toString(16) + 'u256' ;%>;

// Verifier preprocessed input C_0(x)·[1]_1
const C0X: u256 = <%='0x' + BigInt(C0[0]).toString(16) + 'u256' ;%>;
const C0Y: u256 = <%='0x' + BigInt(C0[1]).toString(16) + 'u256' ;%>;

// Verifier preprocessed input x·[1]_2
const X2X1: u256 = <%='0x' + BigInt(X_2[0][0]).toString(16) + 'u256' ;%>;
const X2X2: u256 = <%='0x' + BigInt(X_2[0][1]).toString(16) + 'u256' ;%>;
const X2Y1: u256 = <%='0x' + BigInt(X_2[1][0]).toString(16) + 'u256' ;%>;
const X2Y2: u256 = <%='0x' + BigInt(X_2[1][1]).toString(16) + 'u256' ;%>;

// Scalar field size
const Q: u256 = 0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001u256;
// Base field size
pub const QF: u256 = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD47u256;
// [1]_1
const G1X: u256 = 1;
const G1Y: u256 = 2;
// [1]_2
pub const G2X1: u256 = 0x1800DEEF121F1E76426A00665E5C4479674322D4F75EDADD46DEBD5CD992F6EDu256;
pub const G2X2: u256 = 0x198E9393920D483A7260BFB731FB5D25F1AA493335A9E71297E485B7AEF312C2u256;
pub const G2Y1: u256 = 0x12C85EA5DB8C6DEB4AAB71808DCB408FE3D1E7690C43D37B4CE6CC0166FA7DAAu256;
pub const G2Y2: u256 = 0x90689D0585FF075EC9E99AD690C3395BC4B313370B38EF355ACDADCD122975Bu256;


// G1
pub struct G1Point {
    pub x: u256,
    pub y: u256,
}

// G2
pub struct G2Point {
    pub x: [u256;2],
    pub y: [u256;2],
}

// scalar
pub struct Scalar {
    pub x: u256,
}

// fflonk Proof
pub struct Proof {
    C1: G1Point,
    C2: G1Point,
    W: G1Point,
    W_dash: G1Point,
    q_L: Scalar,
    q_R: Scalar,
    q_M: Scalar,
    q_O: Scalar,
    q_C: Scalar,
    S_sigma_1: Scalar,
    S_sigma_2: Scalar,
    S_sigma_3: Scalar,
    a: Scalar,
    b: Scalar,
    c: Scalar,
    z: Scalar,
    z_omega: Scalar,
    T_1_omega: Scalar,
    T_2_omega: Scalar,
    batch_inv: Scalar, // inv(batch) sent by the prover to avoid any inverse calculation to save gas,
    // we check the correctness of the inv(batch) by computing batch
    // and checking inv(batch) * batch == 1
    // Source: https://github.com/iden3/snarkjs/blob/master/templates/verifier_fflonk.sol.ejs#L96
}

pub struct Roots {
    pub s0_h0w8: [u256;8],
    pub s1_h1w4: [u256;4],
    pub s2_h2w3: [u256;3],
    pub s2_h3w3: [u256;3]
}

pub struct Challenges {
    pub alpha: u256,
    pub beta: u256,
    pub gamma: u256,
    pub y: u256,
    pub xi_seed: u256,
    pub xi_seed2: u256,
    pub xi: u256,
}

pub struct Inverse_vars {
    pub pZhInv: u256,
    pub pDenH1: u256,
    pub pDenH2: u256,
    pub pLiS0Inv: [u256; 8],
    pub pLiS1Inv: [u256;4],
    pub pLiS2Inv: [u256;6],
}

impl u256 {
    fn addmod(self, other: u256) -> u256 {
        let mut res: u256 = 0;
        asm (rA: res, rB: self, rC: other, rD: Q) {
        wqam rA rB rC rD;
        };
        res
    }

    fn mulmod(self, other: u256) -> u256 {
        let mut res: u256 = 0;
        asm (rA: res, rB: self, rC: other, rD: Q) {
        wqmm rA rB rC rD;
        }
        res
    }

    fn submod(self, other: u256) -> u256 {
        let mut res: u256 = Q - other;
        asm (rA: res, rB: self, rD: Q) {
        wqam rA rB rA rD;
        }
        res
    }
}


impl G1Point {

    // https://github.com/FuelLabs/fuel-specs/blob/abfd0bb29fab605e0e067165363581232c40e0bb/src/fuel-vm/instruction-set.md#ecop-elliptic-curve-point-operation
    pub fn point_add(p1: G1Point, p2: G1Point) -> G1Point {
        let mut input: [u256; 4] = [0; 4];
        let mut output: [u256; 2] = [0; 2];

        // prepare input
        input[0] = p1.x;
        input[1] = p1.y;
        input[2] = p2.x;
        input[3] = p2.y;

        // ecc addition opcode
        asm(rA: output, rB: 0, rC: 0, rD: input) {
            ecop rA rB rC rD;
        }
        
        G1Point{
            x: output[0],
            y: output[1],
        }
    }

    // https://github.com/FuelLabs/fuel-specs/blob/abfd0bb29fab605e0e067165363581232c40e0bb/src/fuel-vm/instruction-set.md#ecop-elliptic-curve-point-operation
    pub fn scalar_mul(p: G1Point, s: Scalar) -> G1Point {
        let mut input: [u256; 3] = [0; 3];
        let mut output: [u256; 2] = [0; 2];

        // prepare input
        input[0] = p.x;
        input[1] = p.y;
        input[2] = s.x;

        // ecc multiplication opcode
        asm(rA: output, rB: 0, rC: 1, rD: input) {
            ecop rA rB rC rD;
        }

        G1Point{
            x: output[0],
            y: output[1],
        }
    }

    // Check that the point is on the curve
    // y^2 = x^3 + 3
    pub fn check_point_belongs_to_bn128_curve(p: G1Point) -> bool {

        let mut res: u256 = 0;
        // y^2 mod QF
        asm(rA: res, rB: p.y, rC: p.y, rD: QF) {
            wqmm rA rB rC rD;
        }
        
        // x^3 + 3 mod QF
        let mut res_x: u256 = 0;
        asm(rA: res_x, rB: p.x, rC: p.x, rD: QF, rE: 0x3u256) {
            wqmm rA rB rC rD;
            wqmm rA rA rB rD;
            wqam rA rA rE rD;
        }

        // check if y^2 == x^3 + 3 mod QF
        res_x == res
    }
}

pub fn check_field(v: Scalar) -> bool {
    v.x < Q
}

fn check_input(proof: Proof) -> bool {
    if !G1Point::check_point_belongs_to_bn128_curve(proof.C1) {
        log("C1 point does not belong to the curve.");
        return false;
    }
    if !G1Point::check_point_belongs_to_bn128_curve(proof.C2) {
        log("C2 point does not belong to the curve.");
        return false;
    }
    if !G1Point::check_point_belongs_to_bn128_curve(proof.W) {
        log("W point does not belong to the curve.");
        return false;
    }
    if !G1Point::check_point_belongs_to_bn128_curve(proof.W_dash)
    {
        log("W_dash point does not belong to the curve.");
        return false;
    }
    if !check_field(proof.q_L) {
        log("q_L does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.q_R) {
        log("q_R does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.q_M) {
        log("q_M does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.q_O) {
        log("q_O does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.q_C) {
        log("q_C does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.S_sigma_1) {
        log("S_sigma_1 does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.S_sigma_2) {
        log("S_sigma_2 does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.S_sigma_3) {
        log("S_sigma_3 does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.a) {
        log("a does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.b) {
        log("b does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.c) {
        log("c does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.z) {
        log("z does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.z_omega) {
        log("z_omega does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.T_1_omega) {
        log("T_1_omega does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.T_2_omega) {
        log("T_2_omega does not belong to the Scalar field.");
        return false;
    }
    if !check_field(proof.batch_inv) {
        log("batch_inv does not belong to the Scalar field.");
        return false;
    }

    true
}

// challenges = (alpha, beta, gamma, y, xi_seed, xi_seed^2, xi)
// roots is needed for later computations
// last u256 is Z_H(xi)
fn compute_challenges(proof: &Proof, pub_signals: [u256;<%=Math.max(nPublic, 1)%>]) -> (Challenges, Roots, u256) {
    let mut transcript: Bytes = Bytes::new();

    transcript.append(C0X.to_be_bytes());
    transcript.append(C0Y.to_be_bytes());
    transcript.append(pub_signals[0].to_be_bytes());

    let mut i = 1;
    while i < N_PUBLIC {
        transcript.append(pub_signals[i].to_be_bytes());
        i += 1;
    }

    transcript.append(proof.C1.x.to_be_bytes());
    transcript.append(proof.C1.y.to_be_bytes());

    let mut beta = u256::from(keccak256(transcript));
    // TODO the mod function result into failing of test. why?
    // workaround: using the 256bit addmod 
    beta = beta.addmod(ZERO);

    let mut gamma = u256::from(keccak256(beta.to_be_bytes()));
    gamma = gamma.addmod(ZERO);

    let mut transcript2 = Bytes::new();

    transcript2.append(gamma.to_be_bytes());
    transcript2.append(proof.C2.x.to_be_bytes());
    transcript2.append(proof.C2.y.to_be_bytes());

    // Get xiSeed & xiSeed2
    let mut xi_seed = u256::from(keccak256(transcript2));
    xi_seed = xi_seed.addmod(ZERO);

    let xi_seed2: u256 = xi_seed.mulmod(xi_seed);

    // Compute roots.S0.h0w8
    let H0w8_0: u256 = xi_seed2.mulmod(xi_seed);
    let H0w8_1: u256 = H0w8_0.mulmod(W8_1);
    let H0w8_2: u256 = H0w8_0.mulmod(W8_2);
    let H0w8_3: u256 = H0w8_0.mulmod(W8_3);
    let H0w8_4: u256 = H0w8_0.mulmod(W8_4);
    let H0w8_5: u256 = H0w8_0.mulmod(W8_5);
    let H0w8_6: u256 = H0w8_0.mulmod(W8_6);
    let H0w8_7: u256 = H0w8_0.mulmod(W8_7);

    // Compute roots.S1.h1w4
    let H1w4_0: u256 = H0w8_0.mulmod(H0w8_0);
    let H1w4_1: u256 = H1w4_0.mulmod(W4);
    let H1w4_2: u256 = H1w4_0.mulmod(W4_2);
    let H1w4_3: u256 = H1w4_0.mulmod(W4_3);

    // Compute roots.S2.h2w3
    let H2w3_0: u256 = H1w4_0.mulmod(xi_seed2);
    let H2w3_1: u256 = H2w3_0.mulmod(W3);
    let H2w3_2: u256 = H2w3_0.mulmod(W3_2);

    // Compute roots.S2.h2w3
    let H3w3_0: u256 = H2w3_0.mulmod(WR);
    let H3w3_1: u256 = H3w3_0.mulmod(W3);
    let H3w3_2: u256 = H3w3_0.mulmod(W3_2);

    let mut xin: u256 = 0;
    asm (rA: xin, rB: H2w3_0, rC: H2w3_0, rD: Q) {
        wqmm rA rB rC rD;
        wqmm rA rA rC rD;
    };

    let xi_challenge = xin;

    // Compute xi^n
    //TODO: power must  be generated per contract
    let power = 11;
    let mut i = 0;
    while i < power {
        xin = asm (rA: xin, rB: xin, rC: xin, rD: Q) {
            wqmm rA rB rC rD;
            rA: u256
        };
        i = i + 1;
    }

    xin = xin.addmod(Q-1);

    let Zh = xin;

    let mut transcript3 = Bytes::new();
    transcript3.append(xi_seed.to_be_bytes());
    transcript3.append(proof.q_L.x.to_be_bytes());
    transcript3.append(proof.q_R.x.to_be_bytes());
    transcript3.append(proof.q_M.x.to_be_bytes());
    transcript3.append(proof.q_O.x.to_be_bytes());
    transcript3.append(proof.q_C.x.to_be_bytes());
    transcript3.append(proof.S_sigma_1.x.to_be_bytes());
    transcript3.append(proof.S_sigma_2.x.to_be_bytes());
    transcript3.append(proof.S_sigma_3.x.to_be_bytes());
    transcript3.append(proof.a.x.to_be_bytes());
    transcript3.append(proof.b.x.to_be_bytes());
    transcript3.append(proof.c.x.to_be_bytes());
    transcript3.append(proof.z.x.to_be_bytes());
    transcript3.append(proof.z_omega.x.to_be_bytes());
    transcript3.append(proof.T_1_omega.x.to_be_bytes());
    transcript3.append(proof.T_2_omega.x.to_be_bytes());
    
    // Compute challenge.alpha
    let mut alpha = u256::from(keccak256(transcript3));
    alpha = alpha.addmod(ZERO);

    let mut transcript4 = Bytes::new();
    transcript4.append(alpha.to_be_bytes());
    transcript4.append(proof.W.x.to_be_bytes());
    transcript4.append(proof.W.y.to_be_bytes());

    // Compute challenge.y
    let mut Y = u256::from(keccak256(transcript4));
    Y = Y.addmod(ZERO);

    ( Challenges{ 
        alpha: alpha, 
        beta: beta, 
        gamma: gamma, 
        y: Y,
        xi_seed: xi_seed,
        xi_seed2: xi_seed2,
        xi: xi_challenge
        }, 
    Roots {
        s0_h0w8:[H0w8_0, H0w8_1, H0w8_2, H0w8_3, H0w8_4, H0w8_5, H0w8_6, H0w8_7], 
        s1_h1w4: [H1w4_0, H1w4_1, H1w4_2, H1w4_3], 
        s2_h2w3: [H2w3_0, H2w3_1, H2w3_2], 
        s2_h3w3: [H3w3_0, H3w3_1, H3w3_2]
        },
        Zh,
        )
}

fn compute_li_s0(roots: Roots, challenges: Challenges) -> [u256; 8] {

    let mut li_s0_inv: [u256; 8] = [0; 8];
    let root0 = roots.s0_h0w8[0];
    let y = challenges.y;

    let mut den1: u256 = 1;
    let eight: u256 = 8;
    asm (rA: den1, rC: root0, rD: Q, rE: eight) {
        wqmm rA rA rC rD;
        wqmm rA rA rC rD;
        wqmm rA rA rC rD;
        wqmm rA rA rC rD;
        wqmm rA rA rC rD;
        wqmm rA rA rC rD;
        wqmm rA rE rA rD;
    }
    
    // i = 0
    let mut den2: u256 = roots.s0_h0w8[0];
    let mut den3: u256 = Q - roots.s0_h0w8[0];

    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }

    asm (rA: li_s0_inv[0], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 1
    let mut den2: u256 = roots.s0_h0w8[7];
    let mut den3: u256 = Q - roots.s0_h0w8[1]; 
    asm (rA: den3, rC: challenges.y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s0_inv[1], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 2
    let mut den2: u256 = roots.s0_h0w8[6];
    let mut den3: u256 = Q - roots.s0_h0w8[2]; 
    asm (rA: den3, rC: challenges.y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s0_inv[2], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 3
    let mut den2: u256 = roots.s0_h0w8[5];
    let mut den3: u256 = Q - roots.s0_h0w8[3]; 
    asm (rA: den3, rC: challenges.y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s0_inv[3], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 4
    let mut den2: u256 = roots.s0_h0w8[4];
    let mut den3: u256 = Q - roots.s0_h0w8[4]; 
    asm (rA: den3, rC: challenges.y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s0_inv[4], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 5
    let mut den2: u256 = roots.s0_h0w8[3];
    let mut den3: u256 = Q - roots.s0_h0w8[5]; 
    asm (rA: den3, rC: challenges.y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s0_inv[5], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 6
    let mut den2: u256 = roots.s0_h0w8[2];
    let mut den3: u256 = Q - roots.s0_h0w8[6]; 
    asm (rA: den3, rC: challenges.y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s0_inv[6], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 7
    let mut den2: u256 = roots.s0_h0w8[1];
    let mut den3: u256 = Q - roots.s0_h0w8[7]; 
    asm (rA: den3, rC: challenges.y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s0_inv[7], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    return li_s0_inv;
}

fn compute_li_s1(roots: Roots, challenges: Challenges) -> [u256; 4] {

    let mut li_s1_inv = [0; 4];
    let root0 = roots.s1_h1w4[0];
    let y = challenges.y;

    let mut den1: u256 = 1;
    let four: u256 = 4;
    asm (rA: den1, rB: root0, rC: four, rE: Q) {
        wqmm rA rA rB rE;
        wqmm rA rA rB rE;
        wqmm rA rA rC rE;
    }

    // i = 0
    let mut den2 = roots.s1_h1w4[0];
    let mut den3 = Q - roots.s1_h1w4[0]; 
    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s1_inv[0], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 1
    let mut den2 = roots.s1_h1w4[3];
    let mut den3 = Q - roots.s1_h1w4[1]; 
    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s1_inv[1], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 2
    let mut den2 = roots.s1_h1w4[2];
    let mut den3 = Q - roots.s1_h1w4[2]; 
    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s1_inv[2], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    // i = 3
    let mut den2 = roots.s1_h1w4[1];
    let mut den3 = Q - roots.s1_h1w4[3]; 
    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }    

    asm (rA: li_s1_inv[3], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    }

    return li_s1_inv;
    
}

fn compute_li_s2(roots: Roots, challenges: Challenges) -> [u256; 6] {

    let mut li_s2_inv = [0; 6];
    let y = challenges.y;

    let mut t1: u256 = roots.s2_h2w3[0];
    let mut t2: u256 = 0;
    let three: u256 = 3;
    asm (rA: t1, rB: three, rC: Q, rD: t2, dE: challenges.xi, dF: W1) {
        wqmm rA rA rB rC;
        wqmm rD dE dF rC;
    }

    let mut t3: u256 = Q - t2;
    t3 = t3.addmod(challenges.xi);
    let mut den1: u256 = 0;

    asm (rA: den1, rB: t1, rC: t3, rD: Q) {
        wqmm rA rB rC rD;
    }

    // i = 0
    let mut den2: u256 = roots.s2_h2w3[0];
    let mut den3: u256 = Q - roots.s2_h2w3[0];

    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }

    asm (rA: li_s2_inv[0], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    };

    // i = 1
    let mut den2: u256 = roots.s2_h2w3[2];
    let mut den3: u256 = Q - roots.s2_h2w3[1]; 
    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }

    asm (rA: li_s2_inv[1], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    };

    // i = 2
    let mut den2: u256 = roots.s2_h2w3[1];
    let mut den3: u256 = Q - roots.s2_h2w3[2]; 
    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }

    asm (rA: li_s2_inv[2], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    };

    let mut t1: u256 = roots.s2_h3w3[0];
    let mut t2: u256 = 0; // xi*W1
    let three: u256 = 3;
    asm (rA: t1, rB: three, rC: Q, rD: t2, dE: challenges.xi, dF: W1) {
        wqmm rA rA rB rC;
        wqmm rD dE dF rC;
    }

    let mut t3: u256 = Q - challenges.xi;
    let mut den1: u256 = 0;

    asm (rA: den1, rB: t1, rC: t3, rD: Q, rE: t2) {
        wqam rA rE rC rD;
        wqmm rA rA rB rD;
    };

    // i = 0
    let mut den2: u256 = roots.s2_h3w3[0];
    let mut den3: u256 = Q - roots.s2_h3w3[0]; 
    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }

    asm (rA: li_s2_inv[3], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    };

    // i = 1
    let mut den2: u256 = roots.s2_h3w3[2];
    let mut den3: u256 = Q - roots.s2_h3w3[1]; 
    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }

    asm (rA: li_s2_inv[4], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    };

    // i = 2
    let mut den2: u256 = roots.s2_h3w3[1];
    let mut den3: u256 = Q - roots.s2_h3w3[2]; 
    asm (rA: den3, rC: y, rD: Q) {
        wqam rA rA rC rD;
    }

    asm (rA: li_s2_inv[5], rB: den1, rC: den2, rD: den3, rE: Q) {
        wqmm rA rB rC rE;
        wqmm rA rA rD rE;
    };

    li_s2_inv
}

fn inverse_array(ref mut array: Inverse_vars, ref mut pEval_l: [u256;<%=Math.max(nPublic, 1)%>], pEval_inv: u256) -> (Inverse_vars, [u256;<%=Math.max(nPublic, 1)%>]){
    
    //TODO: this size length should the res array
    let size = 21 + u64::max(N_PUBLIC, 1);

    let mut res: [u256; <%=Math.max(nPublic, 1) + 21%>] = [0; <%=Math.max(nPublic, 1) + 21%>];
    let mut acc = array.pZhInv;

    // pZhInv
    res[0] = acc;

    // pDenH1
    acc = acc.mulmod(array.pDenH1);
    res[1] = acc;

    // pDenH2
    acc = acc.mulmod(array.pDenH2);
    res[2] = acc;



    // pLiS0Inv
    acc = acc.mulmod(array.pLiS0Inv[0]);
    res[3] = acc;



    acc = acc.mulmod(array.pLiS0Inv[1]);
    res[4] = acc;   
    
    acc = acc.mulmod(array.pLiS0Inv[2]);
    res[5] = acc;

    acc = acc.mulmod(array.pLiS0Inv[3]);
    res[6] = acc;

    acc = acc.mulmod(array.pLiS0Inv[4]);
    res[7] = acc;

    acc = acc.mulmod(array.pLiS0Inv[5]);
    res[8] = acc;

    acc = acc.mulmod(array.pLiS0Inv[6]);
    res[9] = acc;

    acc = acc.mulmod(array.pLiS0Inv[7]);
    res[10] = acc;

    // pLiS1Inv
    acc = acc.mulmod(array.pLiS1Inv[0]);
    res[11] = acc;


    acc = acc.mulmod(array.pLiS1Inv[1]);
    res[12] = acc;   
    
    acc = acc.mulmod(array.pLiS1Inv[2]);
    res[13] = acc;

    acc = acc.mulmod(array.pLiS1Inv[3]);
    res[14] = acc;

    // pLiS2Inv
    acc = acc.mulmod(array.pLiS2Inv[0]);
    res[15] = acc;

    acc = acc.mulmod(array.pLiS2Inv[1]);
    res[16] = acc;   
    
    acc = acc.mulmod(array.pLiS2Inv[2]);
    res[17] = acc;

    acc = acc.mulmod(array.pLiS2Inv[3]);
    res[18] = acc;

    acc = acc.mulmod(array.pLiS2Inv[4]);
    res[19] = acc;

    acc = acc.mulmod(array.pLiS2Inv[5]);
    res[20] = acc;

    let mut i = 21;
    while i < size {
        acc = acc.mulmod(pEval_l[i - 21]);
        res[i] = acc;
        i = i + 1;
    }

    let mut inv = pEval_inv;

    // Before using the inverse sent by the prover the verifier checks inv(batch) * batch === 1
    assert(acc.mulmod(inv) == 1);

    acc = inv;
    
    let mut i = size - 1;
    while i > 20 {
        inv = acc.mulmod(res[i-1]);
        acc = acc.mulmod(pEval_l[i - 21]);
        pEval_l[i - 21] = inv;
        i = i - 1;
    }

    inv = acc.mulmod(res[19]);
    acc = acc.mulmod(array.pLiS2Inv[5]);
    array.pLiS2Inv[5] = inv;

    inv = acc.mulmod(res[18]);
    acc = acc.mulmod(array.pLiS2Inv[4]);
    array.pLiS2Inv[4] = inv;

    inv = acc.mulmod(res[17]);
    acc = acc.mulmod(array.pLiS2Inv[3]);
    array.pLiS2Inv[3] = inv;

    inv = acc.mulmod(res[16]);
    acc = acc.mulmod(array.pLiS2Inv[2]);
    array.pLiS2Inv[2] = inv;

    inv = acc.mulmod(res[15]);
    acc = acc.mulmod(array.pLiS2Inv[1]);
    array.pLiS2Inv[1] = inv;

    inv = acc.mulmod(res[14]);
    acc = acc.mulmod(array.pLiS2Inv[0]);
    array.pLiS2Inv[0] = inv;

    inv = acc.mulmod(res[13]);
    acc = acc.mulmod(array.pLiS1Inv[3]);
    array.pLiS1Inv[3] = inv;

    inv = acc.mulmod(res[12]);
    acc = acc.mulmod(array.pLiS1Inv[2]);
    array.pLiS1Inv[2] = inv;

    inv = acc.mulmod(res[11]);
    acc = acc.mulmod(array.pLiS1Inv[1]);
    array.pLiS1Inv[1] = inv;

    inv = acc.mulmod(res[10]);
    acc = acc.mulmod(array.pLiS1Inv[0]);
    array.pLiS1Inv[0] = inv;

    inv = acc.mulmod(res[9]);
    acc = acc.mulmod(array.pLiS0Inv[7]);
    array.pLiS0Inv[7] = inv;

    inv = acc.mulmod(res[8]);
    acc = acc.mulmod(array.pLiS0Inv[6]);
    array.pLiS0Inv[6] = inv;

    inv = acc.mulmod(res[7]);
    acc = acc.mulmod(array.pLiS0Inv[5]);
    array.pLiS0Inv[5] = inv;

    inv = acc.mulmod(res[6]);
    acc = acc.mulmod(array.pLiS0Inv[4]);
    array.pLiS0Inv[4] = inv;

    inv = acc.mulmod(res[5]);
    acc = acc.mulmod(array.pLiS0Inv[3]);
    array.pLiS0Inv[3] = inv;

    inv = acc.mulmod(res[4]);
    acc = acc.mulmod(array.pLiS0Inv[2]);
    array.pLiS0Inv[2] = inv;

    inv = acc.mulmod(res[3]);
    acc = acc.mulmod(array.pLiS0Inv[1]);
    array.pLiS0Inv[1] = inv;

    inv = acc.mulmod(res[2]);
    acc = acc.mulmod(array.pLiS0Inv[0]);
    array.pLiS0Inv[0] = inv;

    inv = acc.mulmod(res[1]);
    acc = acc.mulmod(array.pDenH2);
    array.pDenH2 = inv;

    inv = acc.mulmod(res[0]);
    acc = acc.mulmod(array.pDenH1);
    array.pDenH1 = inv;

    array.pZhInv = acc;

    (array, pEval_l)

}

fn compute_inversion(roots: Roots, challenges: Challenges, zh_inv: u256, eval_inv: u256)  -> (Inverse_vars, [u256;<%=Math.max(nPublic, 1)%>]){

    // 1/((y - h1) (y - h1w4) (y - h1w4_2) (y - h1w4_3))
    let y = challenges.y;
    let mut w: u256 = Q - roots.s1_h1w4[0];
    w = w.addmod(y);

    let mut t = Q - roots.s1_h1w4[1];
    t = t.addmod(y);
    w = w.mulmod(t);

    let mut t = Q - roots.s1_h1w4[2];
    t = t.addmod(y);
    w = w.mulmod(t);

    let mut t = Q - roots.s1_h1w4[3];
    t = t.addmod(y);
    w = w.mulmod(t);

    let den_h1 = w;

    // 1/((y - h2) (y - h2w3) (y - h2w3_2) (y - h3) (y - h3w3) (y - h3w3_2))
    let mut w: u256 = Q - roots.s2_h3w3[0];
    w = w.addmod(y);

    let mut t = Q - roots.s2_h3w3[1];
    t = t.addmod(y);
    w = w.mulmod(t);

    let mut t = Q - roots.s2_h3w3[2];
    t = t.addmod(y);
    w = w.mulmod(t);

    let mut t = Q - roots.s2_h2w3[0];
    t = t.addmod(y);
    w = w.mulmod(t);

    let mut t = Q - roots.s2_h2w3[1];
    t = t.addmod(y);
    w = w.mulmod(t);

    let mut t = Q - roots.s2_h2w3[2];
    t = t.addmod(y);
    w = w.mulmod(t);

    let den_h2 = w;

    let li_s0_inv = compute_li_s0(roots, challenges);
    let li_s1_inv = compute_li_s1(roots, challenges);
    let li_s2_inv = compute_li_s2(roots, challenges);

    let mut w: u256 = 1;
    let xi = challenges.xi;

    let mut i = 1;
    // TODO: change pEval_l: [u256;1] to max(1, N_PUBLIC)

    let mut pEval_l: [u256;1] = [0;1];
    while i <= u64::max(N_PUBLIC, 1) {
        pEval_l[i-1] = u256::from(N).mulmod(xi.submod(w));

        if i < u64::max(N_PUBLIC, 1) {
            w = w.mulmod(W1);
        }
        i = i + 1;
    }

    let mut input: Inverse_vars = Inverse_vars {
        pZhInv: zh_inv,
        pDenH1: den_h1,
        pDenH2: den_h2,
        pLiS0Inv: li_s0_inv,
        pLiS1Inv: li_s1_inv,
        pLiS2Inv: li_s2_inv
    };

    inverse_array(input, pEval_l, eval_inv)
}

fn compute_lagrange(zh: u256, ref mut pEval: [u256; <%=Math.max(nPublic, 1)%>]) -> [u256;<%=Math.max(nPublic, 1)%>]{
    let mut w: u256 = 1;

    let mut i: u64 = 1;
    while (i <= u64::max(N_PUBLIC, 1)) {
        if i == 1 {
            pEval[0] = pEval[0].mulmod(zh);
        }

        else {
            pEval[i - 1] = w.mulmod(pEval[i - 1].mulmod(zh))
        }

        if i < u64::max(N_PUBLIC, 1) {
            w = w.mulmod(W1);
        }

        i = i + 1;
    }

    pEval
}

fn compute_pi(pEval: [u256;<%=Math.max(nPublic, 1)%>], p_pub: [u256;<%=Math.max(nPublic, 1)%>]) -> u256{
    let mut pi: u256 = 0;
    pi = pi.submod(pEval[0].mulmod(p_pub[0]));

    let mut i = 1;
    while i < N_PUBLIC {
        pi = pi.submod(pEval[i].mulmod(p_pub[i]));

        i = i + 1;
    }

    pi
}

fn compute_r0(challenge: Challenges, roots: Roots, proof: Proof, inverse_vars: Inverse_vars) -> u256{
    
    let mut num: u256 = 1;
    let y = challenge.y;

    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y); 

    num = num.addmod(0x00u256.submod(challenge.xi));

    let mut res: u256 = 0;
    let mut h0w80: u256 = 0;
    let mut c0_value: u256 = 0;
    let mut h0w8i: u256 = 0;

    let mut i = 0;
    while i < 8 {
        h0w80 = roots.s0_h0w8[i];
        c0_value = proof.q_L.x.addmod(proof.q_R.x.mulmod(h0w80));
        h0w8i = h0w80.mulmod(h0w80);
        c0_value = c0_value.addmod(proof.q_O.x.mulmod(h0w8i));
        h0w8i = h0w8i.mulmod(h0w80);
        c0_value = c0_value.addmod(proof.q_M.x.mulmod(h0w8i));
        h0w8i = h0w8i.mulmod(h0w80);
        c0_value = c0_value.addmod(proof.q_C.x.mulmod(h0w8i));
        h0w8i = h0w8i.mulmod(h0w80);
        c0_value = c0_value.addmod(proof.S_sigma_1.x.mulmod(h0w8i));
        h0w8i = h0w8i.mulmod(h0w80);
        c0_value = c0_value.addmod(proof.S_sigma_2.x.mulmod(h0w8i));
        h0w8i = h0w8i.mulmod(h0w80);
        c0_value = c0_value.addmod(proof.S_sigma_3.x.mulmod(h0w8i));
        h0w8i = h0w8i.mulmod(h0w80);

        res = res.addmod(c0_value.mulmod(num.mulmod(inverse_vars.pLiS0Inv[i])));

        i = i + 1;
    }

    res

}

fn compute_r1(challenge: Challenges, roots: Roots, proof: Proof, inverse_vars: Inverse_vars, pi: u256) -> u256{
    let mut num: u256 = 1;
    let y = challenge.y;

    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);

    num = num.addmod(0x00u256.submod(challenge.xi));

    let mut t0: u256 = 0;
    let eval_a = proof.a.x;
    let eval_b = proof.b.x;
    let eval_c = proof.c.x;

    t0 = proof.q_L.x.mulmod(eval_a);
    t0 = t0.addmod(proof.q_R.x.mulmod(eval_b));
    t0 = t0.addmod(proof.q_M.x.mulmod(eval_a.mulmod(eval_b)));
    t0 = t0.addmod(proof.q_O.x.mulmod(eval_c));
    t0 = t0.addmod(proof.q_C.x);
    t0 = t0.addmod(pi);
    t0 = t0.mulmod(inverse_vars.pZhInv);

    let mut res: u256 = 0;
    let mut h1w4: u256 = 0;
    let mut c1_value: u256 = 0;
    let mut square: u256 = 0;

    let mut i = 0;
    while i < 4 {
        c1_value = eval_a;
        h1w4 = roots.s1_h1w4[i];
        c1_value = c1_value.addmod(h1w4.mulmod(eval_b));
        square = h1w4.mulmod(h1w4);
        c1_value = c1_value.addmod(square.mulmod(eval_c));
        c1_value = c1_value.addmod(t0.mulmod(square.mulmod(h1w4)));

        res = res.addmod(c1_value.mulmod(num.mulmod(inverse_vars.pLiS1Inv[i])));

        i = i + 1;
    }

    res
}

fn compute_r2(challenge: Challenges, roots: Roots, proof: Proof, inverse_vars: Inverse_vars, pEval_l1: u256) -> u256{
    let y = challenge.y;
    let mut num: u256 = 1;
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);
    num = num.mulmod(y);

    let mut num2: u256 = 1;
    num2 = num2.mulmod(y);
    num2 = num2.mulmod(y);
    num2 = num2.mulmod(y);
    num2 = num2.mulmod(u256::addmod(challenge.xi.mulmod(W1), challenge.xi));

    num = num.submod(num2);


    num2 = u256::mulmod(u256::mulmod(challenge.xi, W1), challenge.xi);

    num = num.addmod(num2);

    let mut t1: u256 = 0;
    let mut t2: u256 = 0;

    let beta_xi: u256 = challenge.beta.mulmod(challenge.xi);
    let mut gamma = challenge.gamma;

    t2 = proof.a.x.addmod(beta_xi.addmod(gamma));
    t2 = t2.mulmod(proof.b.x.addmod(u256::addmod(beta_xi.mulmod(K1), gamma)));
    t2 = t2.mulmod(proof.c.x.addmod(u256::addmod(beta_xi.mulmod(K2), gamma)));
    t2 = t2.mulmod(proof.z.x);

    //Let's use t1 as a temporal variable to save one local
    t1 = proof.a.x.addmod(u256::addmod(u256::mulmod(challenge.beta, proof.S_sigma_1.x), gamma));
    t1 = t1.mulmod(proof.b.x.addmod(u256::addmod(u256::mulmod(challenge.beta, proof.S_sigma_2.x), gamma)));
    t1 = t1.mulmod(proof.c.x.addmod(u256::addmod(u256::mulmod(challenge.beta, proof.S_sigma_3.x), gamma)));
    t1 = t1.mulmod(proof.z_omega.x);

    t2 = t2.submod(t1);
    t2 = t2.mulmod(inverse_vars.pZhInv);

    // Compute T1(xi)
    t1 = proof.z.x.submod(1);
    t1 = t1.mulmod(pEval_l1);
    t1 = t1.mulmod(inverse_vars.pZhInv);

    gamma = 0;
    let mut hw: u256 = roots.s2_h2w3[0];
    let mut c2_value: u256 = proof.z.x.addmod(hw.mulmod(t1));
    c2_value = c2_value.addmod(t2.mulmod(hw.mulmod(hw)));
    gamma = gamma.addmod(u256::mulmod(c2_value, u256::mulmod(num, inverse_vars.pLiS2Inv[0])));

    hw = roots.s2_h2w3[1];
    c2_value = proof.z.x.addmod(hw.mulmod(t1));
    c2_value = c2_value.addmod(t2.mulmod(hw.mulmod(hw)));
    gamma = gamma.addmod(u256::mulmod(c2_value, u256::mulmod(num, inverse_vars.pLiS2Inv[1])));


    hw = roots.s2_h2w3[2];
    c2_value = proof.z.x.addmod(hw.mulmod(t1));
    c2_value = c2_value.addmod(t2.mulmod(hw.mulmod(hw)));
    gamma = gamma.addmod(u256::mulmod(c2_value, u256::mulmod(num, inverse_vars.pLiS2Inv[2])));

    hw = roots.s2_h3w3[0];
    c2_value = proof.z_omega.x.addmod(hw.mulmod(proof.T_1_omega.x));
    c2_value = c2_value.addmod(proof.T_2_omega.x.mulmod(hw.mulmod(hw)));
    gamma = gamma.addmod(u256::mulmod(c2_value, u256::mulmod(num, inverse_vars.pLiS2Inv[3])));

    hw = roots.s2_h3w3[1];
    c2_value = proof.z_omega.x.addmod(hw.mulmod(proof.T_1_omega.x));
    c2_value = c2_value.addmod(proof.T_2_omega.x.mulmod(hw.mulmod(hw)));
    gamma = gamma.addmod(u256::mulmod(c2_value, u256::mulmod(num, inverse_vars.pLiS2Inv[4])));

    hw = roots.s2_h3w3[2];
    c2_value = proof.z_omega.x.addmod(hw.mulmod(proof.T_1_omega.x));
    c2_value = c2_value.addmod(proof.T_2_omega.x.mulmod(hw.mulmod(hw)));
    gamma = gamma.addmod(u256::mulmod(c2_value, u256::mulmod(num, inverse_vars.pLiS2Inv[5])));

    gamma

}

fn compute_fej(challenge: Challenges, proof: Proof, inverse_vars: Inverse_vars, roots: Roots, r0: u256, r1: u256, r2: u256) -> (G1Point, G1Point, G1Point){
    let y = challenge.y;

    let mut numerator: u256 = y.submod(roots.s0_h0w8[0]);
    numerator = numerator.mulmod(y.submod(roots.s0_h0w8[1]));
    numerator = numerator.mulmod(y.submod(roots.s0_h0w8[2]));
    numerator = numerator.mulmod(y.submod(roots.s0_h0w8[3]));
    numerator = numerator.mulmod(y.submod(roots.s0_h0w8[4]));
    numerator = numerator.mulmod(y.submod(roots.s0_h0w8[5]));
    numerator = numerator.mulmod(y.submod(roots.s0_h0w8[6]));
    numerator = numerator.mulmod(y.submod(roots.s0_h0w8[7]));

    // Prepare shared quotient between F and E to reuse it
    let quotient1: u256 = challenge.alpha.mulmod(numerator.mulmod(inverse_vars.pDenH1));
    let quotient2: u256 = challenge.alpha.mulmod(challenge.alpha.mulmod(numerator.mulmod(inverse_vars.pDenH2)));

    let pf: G1Point = G1Point {
        x: C0X,
        y: C0Y,
    };

    // Compute full batched polynomial commitment [F]_1
    let q1: Scalar = Scalar {x: quotient1};
    let q2: Scalar = Scalar {x: quotient2};

    let pf = G1Point::point_add(pf, G1Point::scalar_mul(proof.C1, q1));
    let pf = G1Point::point_add(pf, G1Point::scalar_mul(proof.C2, q2));

    let g1: G1Point = G1Point {
        x: G1X,
        y: G1Y,
    };

    let s1: Scalar = Scalar {
        x: r0.addmod(u256::addmod(u256::mulmod(quotient1, r1), u256::mulmod(quotient2, r2))),
    };

    // Compute group-encoded batch evaluation [E]_1
    let mut pe = G1Point{x: 0, y: 0};
    pe = G1Point::point_add(pe, G1Point::scalar_mul(g1, s1));

    // Compute the full difference [J]_1
    let mut pj = G1Point{x: 0, y:0};
    pj = G1Point::point_add(pj, G1Point::scalar_mul(proof.W, Scalar{x: numerator}));

    (pf, pe, pj)
}

fn check_pairing(pe: G1Point, pf: G1Point, pj: G1Point, proof: Proof, challenge: Challenges) -> u32{

    // prepare input
    let mut input: [u256; 12] = [0;12];

    // First pairing value
    // Compute -E
    let pe = G1Point {
        x: pe.x,
        y: QF - pe.y,
    };

    // Compute -J
    let pj = G1Point {
        x: pj.x,
        y: QF - pj.y,
    };

    // F = F - E - J + y·W2
    let mut pf = G1Point::point_add(pf, pe);
    pf = G1Point::point_add(pf, pj);
    pf = G1Point::point_add(pf, G1Point::scalar_mul(proof.W_dash, Scalar{x: challenge.y}));

    input[0] = pf.x;
    input[1] = pf.y;

    // Second pairing value
    input[2] = G2X2;
    input[3] = G2X1;
    input[4] = G2Y2;
    input[5] = G2Y1;

    // Third pairing value
    // Compute -W2
    input[6] = proof.W_dash.x;
    input[7] = QF - proof.W_dash.y;

    // Fourth pairing value
    input[8] = X2X2;
    input[9] = X2X1;
    input[10] = X2Y2;
    input[11] = X2Y1;

    let groups_of_points: u32 = 2;

    asm(rA, rB: 0, rC: groups_of_points, rD: input) {
        epar rA rB rC rD;
        rA: u32
    }

}

fn verify_proof(proof: Proof, pub_signal: [u256;<%=Math.max(nPublic, 1)%>]) -> bool {

    // Validate that all evaluations ∈ F
    assert(check_input(proof));

    // Compute the challenges: beta, gamma, xi, alpha and y ∈ F, h1w4/h2w3/h3w3 roots, xiN and zh(xi)
    let (challenges, roots, zh) = compute_challenges(&proof, pub_signal);

    // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.
    // The Montgomery batch inversion algorithm allow us to compute n inverses reducing to a single one inversion.
    // To avoid this single inverse computation on-chain, it has been computed in proving time and send it to the verifier.
    // Therefore, the verifier:
    //      1) Prepare all the denominators to inverse
    //      2) Check the inverse sent by the prover it is what it should be
    //      3) Compute the others inverses using the Montgomery Batched Algorithm using the inverse sent to avoid the inversion operation it does.

    let ( inverse_val, pEval_l1)= compute_inversion(roots, challenges, zh, proof.batch_inv.x);
    let mut Eval_l1: [u256;1] = pEval_l1;

    // Compute Lagrange polynomial evaluations Li(xi)
    let eval_l1 = compute_lagrange(zh, Eval_l1);

    // Compute public input polynomial evaluation PI(xi) = \sum_i^l -public_input_i·L_i(xi)
    let pi = compute_pi(eval_l1, pub_signal);

    // Computes r1(y) and r2(y)
    let r0 = compute_r0(challenges, roots, proof, inverse_val);
    let r1 = compute_r1(challenges, roots, proof, inverse_val, pi);
    let r2 = compute_r2(challenges, roots, proof, inverse_val, eval_l1[0]);

    // Compute full batched polynomial commitment [F]_1, group-encoded batch evaluation [E]_1 and the full difference [J]_1
    let (pf, pe, pj) = compute_fej(challenges, proof, inverse_val, roots, r0, r1, r2);

    // Validate all evaluations
    let res = check_pairing(pe, pf, pj, proof, challenges);
    
    if res == 1 {
        return true;
    }

    return false;
}

abi FflonkVerifier {
    fn verify(proof: Proof, pub_signal: [u256;<%=Math.max(nPublic, 1)%>]) -> bool;
}

impl FflonkVerifier for Contract {
    fn verify(proof: Proof, pub_signal: [u256;<%=Math.max(nPublic, 1)%>]) -> bool {
        verify_proof(proof, pub_signal)
    }
}
