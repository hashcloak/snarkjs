// SPDX-License-Identifier: GPL-3.0
/*
Copyright 2021 0KIMS association.

This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

snarkJS is a free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

snarkJS is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
License for more details.

You should have received a copy of the GNU General Public License
along with snarkJS. If not, see
<https: //www.gnu.org/licenses />.
*/

contract;

// Omega
const w1: u256 = <%='0x' + BigInt(w).toString(16) + 'u256' ;%>;
// Scalar field size
const q: u256  = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001u256;
// Base field size
const qf: u256 = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47u256;

// [1]_1
const G1x: u256 = 0x1u256;
const G1y: u256 = 0x2u256;
// [1]_2
const G2x1: u256 = 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6edu256;
const G2x2: u256 = 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2u256;
const G2y1: u256 = 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daau256;
const G2y2: u256 = 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975bu256;

// Verification Key data
const n: u32         = <%=2**power%>;
const nPublic: u16   = <%=nPublic%>;
const nLagrange: u16 = <%=Math.max(nPublic, 1)%>;

const Qmx: u256  = <%='0x' + BigInt(Qm[0]).toString(16) + 'u256' ;%>;
const Qmy: u256  = <%='0x' + BigInt(Qm[0] == "0" ? "0" : Qm[1]).toString(16) + 'u256' ;%>;
const Qlx: u256  = <%='0x' + BigInt(Ql[0]).toString(16) + 'u256' ;%>;
const Qly: u256  = <%='0x' + BigInt(Ql[0] == "0" ? "0" : Ql[1]).toString(16) + 'u256' ;%>;
const Qrx: u256  = <%='0x' + BigInt(Qr[0]).toString(16) + 'u256' ;%>;
const Qry: u256  = <%='0x' + BigInt(Qr[0] == "0" ? "0" : Qr[1]).toString(16) + 'u256' ;%>;
const Qox: u256  = <%='0x' + BigInt(Qo[0]).toString(16) + 'u256' ;%>;
const Qoy: u256  = <%='0x' + BigInt(Qo[0] == "0" ? "0" : Qo[1]).toString(16) + 'u256' ;%>;
const Qcx: u256  = <%='0x' + BigInt(Qc[0]).toString(16) + 'u256' ;%>;
const Qcy: u256  = <%='0x' + BigInt(Qc[0] == "0" ? "0" : Qc[1]).toString(16) + 'u256' ;%>;
const S1x: u256  = <%='0x' + BigInt(S1[0]).toString(16) + 'u256' ;%>;
const S1y: u256  = <%='0x' + BigInt(S1[0] == "0" ? "0" : S1[1]).toString(16) + 'u256' ;%>;
const S2x: u256  = <%='0x' + BigInt(S2[0]).toString(16) + 'u256' ;%>;
const S2y: u256  = <%='0x' + BigInt(S2[0] == "0" ? "0" : S2[1]).toString(16) + 'u256' ;%>;
const S3x: u256  = <%='0x' + BigInt(S3[0]).toString(16) + 'u256' ;%>;
const S3y: u256  = <%='0x' + BigInt(S3[0] == "0" ? "0" : S3[1]).toString(16) + 'u256' ;%>;
const k1: u256   = <%='0x' + BigInt(k1).toString(16) + 'u256' ;%>;
const k2: u256   = <%='0x' + BigInt(k2).toString(16) + 'u256' ;%>;
const X2x1: u256 = <%='0x' + BigInt(X_2[0][0]).toString(16) + 'u256' ;%>;
const X2x2: u256 = <%='0x' + BigInt(X_2[0][1]).toString(16) + 'u256' ;%>;
const X2y1: u256 = <%='0x' + BigInt(X_2[1][0]).toString(16) + 'u256' ;%>;
const X2y2: u256 = <%='0x' + BigInt(X_2[1][1]).toString(16) + 'u256' ;%>;

const Qm: G1Point = G1Point {x: Qmx, y: Qmy };
const Ql: G1Point = G1Point {x: Qlx, y: Qly };
const Qr: G1Point = G1Point {x: Qrx, y: Qry };
const Qo: G1Point = G1Point {x: Qox, y: Qoy };
const Qc: G1Point = G1Point {x: Qcx, y: Qcy };
const S1: G1Point = G1Point {x: S1x, y: S1y };
const S2: G1Point = G1Point {x: S2x, y: S2y };
const S3: G1Point = G1Point {x: S3x, y: S3y };

struct Proof {
  pub proof_A: G1Point,
  pub proof_B: G1Point,
  pub proof_C: G1Point,
  pub proof_Z: G1Point,
  pub proof_T1: G1Point,
  pub proof_T2: G1Point,
  pub proof_T3: G1Point,
  pub proof_Wxi: G1Point,
  pub proof_Wxiw: G1Point,
  pub eval_a: u256,
  pub eval_b: u256,
  pub eval_c: u256,
  pub eval_s1: u256,
  pub eval_s2: u256,
  pub eval_zw: u256,
}


impl Proof {

  // beta, gamma, alpha, xi (=zeta), v, u
  fn get_challenges(self, publicInput: [u256; <%=nPublic%>]) -> [b256;6] {
      let mut transcript: Bytes = Bytes::new();

      ////// BETA
      // Qmx
      // Qmy
      transcript.append(Qmx.to_be_bytes());
      transcript.append(Qmy.to_be_bytes());
      // Qlx
      // Qly
      transcript.append(Qlx.to_be_bytes());
      transcript.append(Qly.to_be_bytes());
      // Qrx
      // Qry
      transcript.append(Qrx.to_be_bytes());
      transcript.append(Qry.to_be_bytes());
      // Qox
      // Qoy
      transcript.append(Qox.to_be_bytes());
      transcript.append(Qoy.to_be_bytes());
      // Qcx
      // Qcy
      transcript.append(Qcx.to_be_bytes());
      transcript.append(Qcy.to_be_bytes());
      // S1x
      // S1y
      transcript.append(S1x.to_be_bytes());
      transcript.append(S1y.to_be_bytes());
      // S2x
      // S2y
      transcript.append(S2x.to_be_bytes());
      transcript.append(S2y.to_be_bytes());
      // S3x
      // S3y
      transcript.append(S3x.to_be_bytes());
      transcript.append(S3y.to_be_bytes());
      // nPublic*32 bytes of public data
      let mut i = 0;
      while i < <%=nPublic%> {
          transcript.append(Bytes::from(publicInput[i].to_be_bytes()));
          i += 1;
      }
      // 64 bytes of pA
      transcript.append(self.proof_A.bytes());
      // 64 bytes of pB
      transcript.append(self.proof_B.bytes());
      // 64 bytes of pC
      transcript.append(self.proof_C.bytes());
      // beta = hash(transcript) mod q
      let beta: b256 = keccak256(transcript);
      asm (rA: beta, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };
      
      ////// GAMMA
      // gamma = hash(beta) mod q
      // Note: this follows snarkjs Plonk verifier beta = hash(transcript) and gamma = hash(beta)
      // While the paper does beta = hash(transcript, 0) and gamma=hash(transcript,1))
      let gamma: b256 = keccak256(beta);
      asm (rA: gamma, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };
      
      ////// ALPHA
      // alpha = hash(beta, gamma, proof_Z) mod q
      let mut transcript: Bytes = Bytes::new();
      transcript.append(Bytes::from(beta));
      transcript.append(Bytes::from(gamma));
      transcript.append(self.proof_Z.bytes());
      let alpha: b256 = keccak256(transcript);
      asm (rA: alpha, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };
      
      ////// XI (xi in Plonk paper)
      // xi = hash(alpha, proof_T1, proof_T2, proof_T3) mod qs
      let mut transcript: Bytes = Bytes::new();
      transcript.append(Bytes::from(alpha));
      transcript.append(self.proof_T1.bytes());
      transcript.append(self.proof_T2.bytes());
      transcript.append(self.proof_T3.bytes());
      let xi: b256 = keccak256(transcript);
      asm (rA: xi, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };

      ////// V
      // v = hash(xi, eval_a, eval_b, eval_c, eval_s1, eval_s2, eval_zw)
      let mut transcript: Bytes = Bytes::new();
      transcript.append(Bytes::from(xi));
      transcript.append(self.eval_a.to_be_bytes());
      transcript.append(self.eval_b.to_be_bytes());
      transcript.append(self.eval_c.to_be_bytes());
      transcript.append(self.eval_s1.to_be_bytes());
      transcript.append(self.eval_s2.to_be_bytes());
      transcript.append(self.eval_zw.to_be_bytes());
      let v: b256 = keccak256(transcript);
      asm (rA: v, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };

      ////// U
      // u = hash(wxi, wxiw)
      let mut transcript: Bytes = Bytes::new();
      transcript.append(self.proof_Wxi.bytes());
      transcript.append(self.proof_Wxiw.bytes());
      let u: b256 = keccak256(transcript);
      asm (rA: u, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };

      return [beta, gamma, alpha, xi, v, u]
  }

}