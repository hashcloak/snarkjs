// SPDX-License-Identifier: GPL-3.0
/*
Copyright 2021 0KIMS association.

This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

snarkJS is a free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

snarkJS is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
License for more details.

You should have received a copy of the GNU General Public License
along with snarkJS. If not, see
<https: //www.gnu.org/licenses />.
*/

contract;

// Omega
const w1: u256 = <%='0x' + BigInt(w).toString(16) + 'u256' ;%>;
// Scalar field size
const q: u256  = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001u256;
// Base field size
const qf: u256 = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47u256;

// [1]_1
const G1x: u256 = 0x1u256;
const G1y: u256 = 0x2u256;
// [1]_2
const G2x1: u256 = 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6edu256;
const G2x2: u256 = 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2u256;
const G2y1: u256 = 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daau256;
const G2y2: u256 = 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975bu256;

// Verification Key data
const n: u32         = <%=2**power%>;
const nPublic: u16   = <%=nPublic%>;
const nLagrange: u16 = <%=Math.max(nPublic, 1)%>;

const Qmx: u256  = <%='0x' + BigInt(Qm[0]).toString(16) + 'u256' ;%>;
const Qmy: u256  = <%='0x' + BigInt(Qm[0] == "0" ? "0" : Qm[1]).toString(16) + 'u256' ;%>;
const Qlx: u256  = <%='0x' + BigInt(Ql[0]).toString(16) + 'u256' ;%>;
const Qly: u256  = <%='0x' + BigInt(Ql[0] == "0" ? "0" : Ql[1]).toString(16) + 'u256' ;%>;
const Qrx: u256  = <%='0x' + BigInt(Qr[0]).toString(16) + 'u256' ;%>;
const Qry: u256  = <%='0x' + BigInt(Qr[0] == "0" ? "0" : Qr[1]).toString(16) + 'u256' ;%>;
const Qox: u256  = <%='0x' + BigInt(Qo[0]).toString(16) + 'u256' ;%>;
const Qoy: u256  = <%='0x' + BigInt(Qo[0] == "0" ? "0" : Qo[1]).toString(16) + 'u256' ;%>;
const Qcx: u256  = <%='0x' + BigInt(Qc[0]).toString(16) + 'u256' ;%>;
const Qcy: u256  = <%='0x' + BigInt(Qc[0] == "0" ? "0" : Qc[1]).toString(16) + 'u256' ;%>;
const S1x: u256  = <%='0x' + BigInt(S1[0]).toString(16) + 'u256' ;%>;
const S1y: u256  = <%='0x' + BigInt(S1[0] == "0" ? "0" : S1[1]).toString(16) + 'u256' ;%>;
const S2x: u256  = <%='0x' + BigInt(S2[0]).toString(16) + 'u256' ;%>;
const S2y: u256  = <%='0x' + BigInt(S2[0] == "0" ? "0" : S2[1]).toString(16) + 'u256' ;%>;
const S3x: u256  = <%='0x' + BigInt(S3[0]).toString(16) + 'u256' ;%>;
const S3y: u256  = <%='0x' + BigInt(S3[0] == "0" ? "0" : S3[1]).toString(16) + 'u256' ;%>;
const k1: u256   = <%='0x' + BigInt(k1).toString(16) + 'u256' ;%>;
const k2: u256   = <%='0x' + BigInt(k2).toString(16) + 'u256' ;%>;
const X2x1: u256 = <%='0x' + BigInt(X_2[0][0]).toString(16) + 'u256' ;%>;
const X2x2: u256 = <%='0x' + BigInt(X_2[0][1]).toString(16) + 'u256' ;%>;
const X2y1: u256 = <%='0x' + BigInt(X_2[1][0]).toString(16) + 'u256' ;%>;
const X2y2: u256 = <%='0x' + BigInt(X_2[1][1]).toString(16) + 'u256' ;%>;

const Qm: G1Point = G1Point {x: Qmx, y: Qmy };
const Ql: G1Point = G1Point {x: Qlx, y: Qly };
const Qr: G1Point = G1Point {x: Qrx, y: Qry };
const Qo: G1Point = G1Point {x: Qox, y: Qoy };
const Qc: G1Point = G1Point {x: Qcx, y: Qcy };
const S1: G1Point = G1Point {x: S1x, y: S1y };
const S2: G1Point = G1Point {x: S2x, y: S2y };
const S3: G1Point = G1Point {x: S3x, y: S3y };

struct Proof {
  pub proof_A: G1Point,
  pub proof_B: G1Point,
  pub proof_C: G1Point,
  pub proof_Z: G1Point,
  pub proof_T1: G1Point,
  pub proof_T2: G1Point,
  pub proof_T3: G1Point,
  pub proof_Wxi: G1Point,
  pub proof_Wxiw: G1Point,
  pub eval_a: u256,
  pub eval_b: u256,
  pub eval_c: u256,
  pub eval_s1: u256,
  pub eval_s2: u256,
  pub eval_zw: u256,
}


impl Proof {

  // beta, gamma, alpha, xi (=zeta), v, u
  fn get_challenges(self, publicInput: [u256; <%=nPublic%>]) -> [b256;6] {
      let mut transcript: Bytes = Bytes::new();

      ////// BETA
      // Qmx
      // Qmy
      transcript.append(Qmx.to_be_bytes());
      transcript.append(Qmy.to_be_bytes());
      // Qlx
      // Qly
      transcript.append(Qlx.to_be_bytes());
      transcript.append(Qly.to_be_bytes());
      // Qrx
      // Qry
      transcript.append(Qrx.to_be_bytes());
      transcript.append(Qry.to_be_bytes());
      // Qox
      // Qoy
      transcript.append(Qox.to_be_bytes());
      transcript.append(Qoy.to_be_bytes());
      // Qcx
      // Qcy
      transcript.append(Qcx.to_be_bytes());
      transcript.append(Qcy.to_be_bytes());
      // S1x
      // S1y
      transcript.append(S1x.to_be_bytes());
      transcript.append(S1y.to_be_bytes());
      // S2x
      // S2y
      transcript.append(S2x.to_be_bytes());
      transcript.append(S2y.to_be_bytes());
      // S3x
      // S3y
      transcript.append(S3x.to_be_bytes());
      transcript.append(S3y.to_be_bytes());
      // nPublic*32 bytes of public data
      let mut i = 0;
      while i < <%=nPublic%> {
          transcript.append(Bytes::from(publicInput[i].to_be_bytes()));
          i += 1;
      }
      // 64 bytes of pA
      transcript.append(self.proof_A.bytes());
      // 64 bytes of pB
      transcript.append(self.proof_B.bytes());
      // 64 bytes of pC
      transcript.append(self.proof_C.bytes());
      // beta = hash(transcript) mod q
      let beta: b256 = keccak256(transcript);
      asm (rA: beta, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };
      
      ////// GAMMA
      // gamma = hash(beta) mod q
      // Note: this follows snarkjs Plonk verifier beta = hash(transcript) and gamma = hash(beta)
      // While the paper does beta = hash(transcript, 0) and gamma=hash(transcript,1))
      let gamma: b256 = keccak256(beta);
      asm (rA: gamma, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };
      
      ////// ALPHA
      // alpha = hash(beta, gamma, proof_Z) mod q
      let mut transcript: Bytes = Bytes::new();
      transcript.append(Bytes::from(beta));
      transcript.append(Bytes::from(gamma));
      transcript.append(self.proof_Z.bytes());
      let alpha: b256 = keccak256(transcript);
      asm (rA: alpha, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };
      
      ////// XI (xi in Plonk paper)
      // xi = hash(alpha, proof_T1, proof_T2, proof_T3) mod qs
      let mut transcript: Bytes = Bytes::new();
      transcript.append(Bytes::from(alpha));
      transcript.append(self.proof_T1.bytes());
      transcript.append(self.proof_T2.bytes());
      transcript.append(self.proof_T3.bytes());
      let xi: b256 = keccak256(transcript);
      asm (rA: xi, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };

      ////// V
      // v = hash(xi, eval_a, eval_b, eval_c, eval_s1, eval_s2, eval_zw)
      let mut transcript: Bytes = Bytes::new();
      transcript.append(Bytes::from(xi));
      transcript.append(self.eval_a.to_be_bytes());
      transcript.append(self.eval_b.to_be_bytes());
      transcript.append(self.eval_c.to_be_bytes());
      transcript.append(self.eval_s1.to_be_bytes());
      transcript.append(self.eval_s2.to_be_bytes());
      transcript.append(self.eval_zw.to_be_bytes());
      let v: b256 = keccak256(transcript);
      asm (rA: v, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };

      ////// U
      // u = hash(wxi, wxiw)
      let mut transcript: Bytes = Bytes::new();
      transcript.append(self.proof_Wxi.bytes());
      transcript.append(self.proof_Wxiw.bytes());
      let u: b256 = keccak256(transcript);
      asm (rA: u, rC: ZERO, rD: q) {
          wqam rA rA rC rD;
      };

      return [beta, gamma, alpha, xi, v, u]
  }

  // TODO return more pEval_i , where i=0..nPublic
  // and pEval_i = wi^i * (pXi-wi^i)
  // TODO calculate inverse to finish up the value
  // num, denom, xi^n
  fn calculateLagrange(self, xi: u256, w: u256) -> (u256, u256, u256) {
    // n(xi-w) mod q
    let mut denom: u256 = 0;
    let temp = xi - w;
    // mem[$rA,32] = (b*c)%d
    asm (rA: denom, rB: temp, rC: n, rD: q) {
      wqmm rA rB rC rD;
    };
    
    // 2. xi^n-w, where in practice n is a power of 2
    let power = <%=power%>;
    let mut i = 0;
    let mut xi_pow_n: u256 = xi;
    while i < power {
        // mem[$rA,32] = (b*c)%d
        asm (rA: xi_pow_n, rB: xi_pow_n, rC: xi_pow_n, rD: q) {
          wqmm rA rB rC rD;
        };

        i = i + 1;
    }
    let num: u256 = xi_pow_n - w;

    // TODO invert denom
    // return (xiˆn-w) / n*(xi-w), xi_pow_n
    return (num, denom, xi_pow_n);
  }

  // SUM(w_i*L_i(xi)) 
  fn calculatePI(self, pEval: [u256; <%=nPublic%>], publicInput: [u256; <%=nPublic%>]) -> u256 {
      let mut res: u256 = 0;
      let mut temp: u256 = 0;
      let mut i = 0;
      while i < nPublic {
        // temp = pEval[i]*publicInput[i] mod q
        asm (rA: temp, rB: pEval[i], rC: publicInput[i], rD: q) {
            wqmm rA rB rC rD;
        };
        // accumulate all values in res
        // res = res + temp
        asm (rA: res, rB: res, rC: temp, rD: q) {
          wqam rA rB rC rD;
        };
        i = i + 1;
      }

      // Same as in Solidity code, negate PI
      return q - res;
  }

  // r0 := PI(z) − L1(z)α2 − α(¯a + β¯sσ1 + γ)(¯b + β¯sσ2 + γ)(¯c + γ)¯zω,
  fn calculateR0(self,
    PIz: u256, 
    pEval_l1: u256,
    alpha: u256,
    alpha_squared: u256,
    beta: u256,
    gamma: u256) -> u256 {
      ///// SECOND TERM
      // L1(z)α2 
      let mut second_term: u256 = 0;
      asm (rA: second_term, rB: pEval_l1, rC: alpha_squared, rD: q) {
        wqmm rA rB rC rD;
      };
      
      ///// THIRD TERM
      // part 1: (¯a + β¯sσ1 + γ)
      
      // Step 1: third_term_1 =  β¯sσ1
      let mut third_term_1: u256 = 0;
      asm (rA: third_term_1, rB: beta, rC: self.eval_s1, rD: q) {
        wqmm rA rB rC rD;
      };
      // Step 2: third_term_1 =  ¯a + β¯sσ1
      asm (rA: third_term_1, rB: self.eval_a, rC: third_term_1, rD: q) {
        wqam rA rB rC rD;
      };
      // Step 3: third_term_1 = ¯a + β¯sσ1 + γ
      asm (rA: third_term_1, rB: third_term_1, rC: gamma, rD: q) {
        wqam rA rB rC rD;
      };

      // part 2: (¯b + β¯sσ2 + γ)
      let mut third_term_2: u256 = 0;
      asm (rA: third_term_2, rB: beta, rC: self.eval_s2, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: third_term_2, rB: self.eval_b, rC: third_term_2, rD: q) {
        wqam rA rB rC rD;
      };
      asm (rA: third_term_2, rB: third_term_2, rC: gamma, rD: q) {
        wqam rA rB rC rD;
      };

      // part 3: (¯c + γ)
      let mut third_term_3: u256 = 0;
      asm (rA: third_term_3, rB: self.eval_c, rC: gamma, rD: q) {
        wqam rA rB rC rD;
      };

      // α(¯a + β¯sσ1 + γ)(¯b + β¯sσ2 + γ)(¯c + γ)¯zω
      let mut temp0: u256 = 0;
      asm (rA: temp0, rB: alpha, rC: third_term_1, rD: q) {
        wqmm rA rB rC rD;
      };
      let mut temp1: u256 = 0;
      asm (rA: temp1, rB: third_term_2, rC: third_term_3, rD: q) {
        wqmm rA rB rC rD;
      };
      let mut third_term: u256 = 0;
      asm (rA: third_term, rB: self.eval_zw, rC: temp0, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: third_term, rB: third_term, rC: temp1, rD: q) {
        wqmm rA rB rC rD;
      };

      // PI(z) − L1(z)α2 − α(¯a + β¯sσ1 + γ)(¯b + β¯sσ2 + γ)(¯c + γ)¯zω
      // PI(z) + (q - L1(z)α2) + (q - α(¯a + β¯sσ1 + γ)(¯b + β¯sσ2 + γ)(¯c + γ)¯zω)

      let mut q_minus_second: u256 = q - second_term;
      let mut q_minus_third: u256 = q - third_term;

      let mut res: u256 = 0;
      asm (rA: res, rB: PIz, rC: q_minus_second, rD: q) {
        wqam rA rB rC rD;
      };
      asm (rA: res, rB: res, rC: q_minus_third, rD: q) {
        wqam rA rB rC rD;
      };
      return res;
  }
  
  fn calculateD(self,
    pEval_l1: u256,
    alpha: u256,
    alpha_squared: u256,
    beta: u256,
    gamma: u256,
    xi: u256, // xi
    xi_pow_n: u256, // xi^n
    v: u256,
    u: u256) -> G1Point {

      //// TERM 1
      let mut point_term_1 = Qc;
      // eval_a*eval_b*Gm
      let mut temp0: u256 = 0;
      asm (rA: temp0, rB: self.eval_a, rC: self.eval_b, rD: q) {
        wqmm rA rB rC rD;
      };
      let temp0_point = Qm.u256_mul(temp0);
      point_term_1 = point_term_1.point_add(temp0_point);
      //eval_a*Ql
      let temp1_point = Ql.u256_mul(self.eval_a);
      point_term_1 = point_term_1.point_add(temp1_point);
      //eval_b*Qr
      let temp2_point = Qr.u256_mul(self.eval_b);
      point_term_1 = point_term_1.point_add(temp2_point);
      //eval_c*Qo
      let temp3_point = Qo.u256_mul(self.eval_c);
      point_term_1 = point_term_1.point_add(temp3_point);

      //// TERM 2
      // (¯a + βz + γ)
      let mut betaxi: u256 = 0;
      asm (rA: betaxi, rB: beta, rC: xi, rD: q) {
        wqmm rA rB rC rD;
      };
      let mut val1: u256 = 0;
      asm (rA: val1, rB: betaxi, rC: self.eval_a, rD: q) {
        wqam rA rB rC rD;
      };
      asm (rA: val1, rB: val1, rC: gamma, rD: q) {
        wqam rA rB rC rD;
      };

      // (¯b + βk1z + γ)
      let mut val2: u256 = 0;
      asm (rA: val2, rB: betaxi, rC: k1, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: val2, rB: val2, rC: self.eval_b, rD: q) {
        wqam rA rB rC rD;
      };
      asm (rA: val2, rB: val2, rC: gamma, rD: q) {
        wqam rA rB rC rD;
      };

      // (¯c + βk2z + γ)
      let mut val3: u256 = 0;
      asm (rA: val3, rB: betaxi, rC: k2, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: val3, rB: val3, rC: self.eval_c, rD: q) {
        wqam rA rB rC rD;
      };
      asm (rA: val3, rB: val3, rC: gamma, rD: q) {
        wqam rA rB rC rD;
      };

      // (¯a + βz + γ)(¯b + βk1z + γ)(¯c + βk2z + γ)α
      let mut d2a: u256 = 0;
      asm (rA: d2a, rB: val1, rC: val2, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: d2a, rB: d2a, rC: val3, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: d2a, rB: d2a, rC: alpha, rD: q) {
        wqmm rA rB rC rD;
      };

      // L1(z)α2
      let mut d3a: u256 = 0;
      asm (rA: d3a, rB: pEval_l1, rC: alpha_squared, rD: q) {
        wqmm rA rB rC rD;
      };

      // (¯a + βz + γ)(¯b + βk1z + γ)(¯c + βk2z + γ)α + L1(z)α2 + u
      let mut u256_term_2: u256 = 0;
      asm (rA: u256_term_2, rB: d2a, rC: d3a, rD: q) {
        wqam rA rB rC rD;
      };
      asm (rA: u256_term_2, rB: u256_term_2, rC: u, rD: q) {
        wqam rA rB rC rD;
      };

      // ((¯a + βz + γ)(¯b + βk1z + γ)(¯c + βk2z + γ)α + L1(z)α2 + u) · [z]1
      let point_term2 = self.proof_Z.u256_mul(u256_term_2);

      //// TERM 3
      // (¯a + β¯sσ1 + γ)
      asm (rA: val1, rB: beta, rC: self.eval_s1, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: val1, rB: val1, rC: self.eval_a, rD: q) {
        wqam rA rB rC rD;
      };
      asm (rA: val1, rB: val1, rC: gamma, rD: q) {
        wqam rA rB rC rD;
      };

      // (¯b + β¯sσ2 + γ)
      asm (rA: val2, rB: beta, rC: self.eval_s2, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: val2, rB: val2, rC: self.eval_b, rD: q) {
        wqam rA rB rC rD;
      };
      asm (rA: val2, rB: val2, rC: gamma, rD: q) {
        wqam rA rB rC rD;
      };

      // αβ¯zω
      asm (rA: val3, rB: alpha, rC: beta, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: val3, rB: val3, rC: self.eval_zw, rD: q) {
        wqmm rA rB rC rD;
      };

      // (¯a + β¯sσ1 + γ)(¯b + β¯sσ2 + γ)αβ¯zω
      let mut u256_term3: u256 = 0;
      asm (rA: u256_term3, rB: val1, rC: val2, rD: q) {
        wqmm rA rB rC rD;
      };
      asm (rA: u256_term3, rB: u256_term3, rC: val3, rD: q) {
        wqmm rA rB rC rD;
      };

      // (¯a + β¯sσ1 + γ)(¯b + β¯sσ2 + γ)αβ¯zω · [sσ3]1
      let point_term3 = S3.u256_mul(u256_term3);

      //// TERM 4
      let mut point_term4: G1Point = self.proof_T1;
      // xi^n[t_mid]1
      let mut temp_point: G1Point = self.proof_T2.u256_mul(xi_pow_n);
      point_term4 = point_term4.point_add(temp_point);
      
      // xi^2n
      asm (rA: val2, rB: xi_pow_n, rC: xi_pow_n, rD: q) {
        wqmm rA rB rC rD;
      };
      // xi^2n · [t_hi]1
      temp_point = self.proof_T3.u256_mul(val2);
      point_term4 = point_term4.point_add(temp_point);

      // ZH(z)([tlo]1 + zn · [tmid]1 + z2n · [thi]1)
      point_term4 = point_term4.u256_mul(xi_pow_n - 1);

      // negate point term3
      let neg_y_3: u256 = qf - point_term3.y;
      let neg_term3 = G1Point{
          x: point_term3.x,
          y: neg_y_3
      };
      let mut neg_y_bytes: [u8; 64] = neg_term3.to_bytes();

      // negate point term4
      let neg_y_4 = qf - point_term4.y;
      let neg_term4 = G1Point{
          x: point_term4.x,
          y: neg_y_4
      };
      let mut res: G1Point = point_term_1.point_add(point_term2);
      res = res.point_add(neg_term3);
      res = res.point_add(neg_term4);
      return res;
  }

  fn calculateF(self,
    v: u256,
    v2: u256,
    v3: u256,
    v4: u256,
    v5: u256,
    D: G1Point
  ) -> G1Point {
      // D + v · [a]1
      let mut temp: G1Point = self.proof_A.u256_mul(v);
      let mut res: G1Point = D.point_add(temp);
      // v2 · [b]1
      temp = self.proof_B.u256_mul(v2);
      res = res.point_add(temp);
      // v3 · [c]1
      temp = self.proof_C.u256_mul(v3);
      res = res.point_add(temp);
      // v4 · [sσ1]1
      temp = S1.u256_mul(v4);
      res = res.point_add(temp);
      // v5 · [sσ2]1
      temp = S2.u256_mul(v5);
      res = res.point_add(temp);
      return res; 
  }

  fn calculateE(self,
    r0: u256,
    u: u256,
    v: u256,
    v2: u256,
    v3: u256,
    v4: u256,
    v5: u256,
    ) -> G1Point {
      // −r0 + v¯a + v2¯b + v3¯c + v4¯sσ1 + v5¯sσ2 + u¯zω
      // q-r0
      let mut acc_u256: u256 = q - r0;
      let mut temp: u256 = 0;
      asm (rA: temp, rB: v, rC: self.eval_a, rD: q) {
        wqmm rA rB rC rD;
      };
      acc_u256 += temp;
      asm (rA: temp, rB: v2, rC: self.eval_b, rD: q) {
        wqmm rA rB rC rD;
      };
      acc_u256 += temp;
      asm (rA: temp, rB: v3, rC: self.eval_c, rD: q) {
        wqmm rA rB rC rD;
      };
      acc_u256 += temp;
      asm (rA: temp, rB: v4, rC: self.eval_s1, rD: q) {
        wqmm rA rB rC rD;
      };
      acc_u256 += temp;
      asm (rA: temp, rB: v5, rC: self.eval_s2, rD: q) {
        wqmm rA rB rC rD;
      };
      acc_u256 += temp;
      asm (rA: temp, rB: u, rC: self.eval_zw, rD: q) {
        wqmm rA rB rC rD;
      };
      acc_u256 += temp;
      let res = G1.u256_mul(acc_u256);
      return res; 
  }
}